use std::env;
use std::fs;
use std::path::Path;
use std::time::{SystemTime, UNIX_EPOCH};

fn xorshift64(state: &mut u64) -> u64 {
    let mut x = *state;
    x ^= x << 13;
    x ^= x >> 7;
    x ^= x << 17;
    *state = x;
    x
}

fn main() {
    println!("cargo:rerun-if-changed=build.rs");

    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("time")
        .as_nanos();
    let pid = std::process::id() as u64;
    let mut state = (now as u64) ^ (pid.rotate_left(17));

    let mut key = [0u8; 16];
    for i in 0..16 {
        let v = xorshift64(&mut state);
        key[i] = (v >> ((i % 8) * 8)) as u8;
    }

    let mut key_a = [0u8; 16];
    let mut key_b = [0u8; 16];
    for i in 0..16 {
        let mask = xorshift64(&mut state) as u8;
        key_a[i] = key[i] ^ mask;
        key_b[i] = mask;
    }

    let seed = (xorshift64(&mut state) & 0xFF) as u8;

    let mut plain_spoof = [0xCCu8; 32];
    // mov r10, rcx
    plain_spoof[0] = 0x4C;
    plain_spoof[1] = 0x8B;
    plain_spoof[2] = 0xD1;
    // mov eax, imm32 (ssn)
    plain_spoof[3] = 0xB8;
    // 4..=7: ssn placeholder
    // add rsp, 8  (skip fake top frame during syscall)
    plain_spoof[8] = 0x48;
    plain_spoof[9] = 0x83;
    plain_spoof[10] = 0xC4;
    plain_spoof[11] = 0x08;
    // syscall
    plain_spoof[12] = 0x0F;
    plain_spoof[13] = 0x05;
    // sub rsp, 8  (restore real return address for ret)
    plain_spoof[14] = 0x48;
    plain_spoof[15] = 0x83;
    plain_spoof[16] = 0xEC;
    plain_spoof[17] = 0x08;
    // ret
    plain_spoof[18] = 0xC3;

    let mut plain_plain = [0xCCu8; 32];
    // mov r10, rcx
    plain_plain[0] = 0x4C;
    plain_plain[1] = 0x8B;
    plain_plain[2] = 0xD1;
    // mov eax, imm32 (ssn)
    plain_plain[3] = 0xB8;
    // 4..=7: ssn placeholder
    // syscall
    plain_plain[8] = 0x0F;
    plain_plain[9] = 0x05;
    // ret
    plain_plain[10] = 0xC3;

    let mut enc_spoof = [0u8; 32];
    let mut enc_plain = [0u8; 32];
    for i in 0..32 {
        let mix = (i as u8).wrapping_mul(17).wrapping_add(seed);
        enc_spoof[i] = plain_spoof[i] ^ key[i % 16] ^ mix;
        enc_plain[i] = plain_plain[i] ^ key[i % 16] ^ mix;
    }

    let out_dir = env::var("OUT_DIR").expect("OUT_DIR");
    let dest = Path::new(&out_dir).join("stub_template.rs");

    let mut s = String::new();
    s.push_str("// @generated by build.rs. Do not edit.\n");
    s.push_str("pub const STUB_TEMPLATE_ENC_SPOOF: [u8; 32] = [");
    for (i, b) in enc_spoof.iter().enumerate() {
        if i != 0 {
            s.push_str(", ");
        }
        s.push_str(&format!("0x{:02X}", b));
    }
    s.push_str("];\n");

    s.push_str("pub const STUB_TEMPLATE_ENC_PLAIN: [u8; 32] = [");
    for (i, b) in enc_plain.iter().enumerate() {
        if i != 0 {
            s.push_str(", ");
        }
        s.push_str(&format!("0x{:02X}", b));
    }
    s.push_str("];\n");

    s.push_str("pub const STUB_KEY_A: [u8; 16] = [");
    for (i, b) in key_a.iter().enumerate() {
        if i != 0 {
            s.push_str(", ");
        }
        s.push_str(&format!("0x{:02X}", b));
    }
    s.push_str("];\n");

    s.push_str("pub const STUB_KEY_B: [u8; 16] = [");
    for (i, b) in key_b.iter().enumerate() {
        if i != 0 {
            s.push_str(", ");
        }
        s.push_str(&format!("0x{:02X}", b));
    }
    s.push_str("];\n");

    s.push_str(&format!("pub const STUB_SEED: u8 = 0x{:02X};\n", seed));

    fs::write(dest, s).expect("write stub_template.rs");
}
